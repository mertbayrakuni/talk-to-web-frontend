<!-- chatbot.html â€” popup grows from an origin element (mini card) -->
<style>
    /* ============ CORE CHAT UI ============ */
    .ttw-chatbot {
        box-sizing: border-box;
        width: 100%;
        max-width: 780px;
        margin: 0 auto;
        display: flex;
        flex-direction: column;
        gap: 12px;
        font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial, sans-serif;
    }

    /* header hidden per request */
    .ttw-h {
        display: none !important;
    }

    .ttw-log {
        background: #fff;
        border-radius: 12px;
        padding: 12px;
        height: 420px;
        overflow: auto;
        display: flex;
        flex-direction: column;
        gap: 10px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, .05);
    }

    .ttw-b {
        padding: 10px 14px;
        border-radius: 14px;
        max-width: 80%;
        position: relative;
        box-shadow: 0 2px 4px rgba(0, 0, 0, .05);
    }

    /* ChatGPT-light bubble colors */
    .ttw-b.u {
        margin-left: auto;
        background: #dcfce7;
        color: #0c0c0d;
        border-bottom-right-radius: 6px;
    }

    .ttw-b.a {
        margin-right: auto;
        background: #f7f7f8;
        color: #0c0c0d;
        border-bottom-left-radius: 6px;
    }

    .ttw-ts {
        font-size: 11px;
        color: #6b7280;
        opacity: .9;
        margin-top: 6px;
        text-align: right;
    }

    /* ============ INPUT ROW ============ */
    .ttw-row {
        display: flex;
        align-items: center;
        gap: 10px;
        position: relative;
        padding: 8px;
    }

    .ttw-inp {
        flex: 1;
        padding: 12px 14px;
        font-size: 15px;
        outline: none;
        background: #fff;
        color: #0c0c0d;
        border: 1px solid #d9d9e3;
        border-radius: 22px;
    }

    .ttw-inp::placeholder {
        color: #6b7280;
    }

    .ttw-inp:focus {
        border-color: #10a37f;
        box-shadow: 0 0 0 2px rgba(16, 163, 127, .35);
    }

    /* buttons */
    .ttw-send, .ttw-btn, .ttw-ok, .ttw-cancel {
        padding: 10px 18px;
        border: 0;
        border-radius: 24px;
        font-weight: 600;
        cursor: pointer;
    }

    .ttw-send {
        background: #10a37f;
        color: #fff;
        box-shadow: 0 4px 8px rgba(0, 0, 0, .1);
    }

    .ttw-send:hover {
        background: #0e8f70;
    }

    .ttw-send:active {
        background: #0c7e63;
    }

    .ttw-send:disabled {
        background: #a7dacd;
        cursor: not-allowed;
    }

    /* mic button (round) */
    .ttw-mic {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 44px;
        height: 44px;
        border: 0;
        border-radius: 999px;
        cursor: pointer;
        background: #fff;
        box-shadow: 0 0 0 1px rgba(0, 0, 0, .1) inset;
    }

    .ttw-mic.rec {
        box-shadow: 0 0 0 2px rgba(233, 67, 67, .25) inset;
        animation: ttw-pulse 1.2s ease-in-out infinite;
    }

    @keyframes ttw-pulse {
        0% {
            transform: scale(1)
        }
        50% {
            transform: scale(1.06)
        }
        100% {
            transform: scale(1)
        }
    }

    /* OK / Ä°ptal appear only while recording (toggled by JS) */
    .ttw-ok {
        background: #19a974;
        color: #fff;
        display: none;
    }

    .ttw-cancel {
        background: #fff;
        box-shadow: 0 0 0 1px rgba(0, 0, 0, .12) inset;
        display: none;
    }

    /* collapse the input during recording so it doesn't push buttons */
    .ttw-inp.is-voice {
        opacity: 0;
        pointer-events: none;
        width: 0;
        padding: 0;
        border: 0;
        margin: 0;
        flex: 0 0 0;
    }

    /* while recording, create a flex spacer so buttons stay at the far right */
    .ttw-row.rec::before {
        content: "";
        flex: 1 1 auto;
    }

    /* show/hide the right buttons by state */
    .ttw-row.rec .ttw-send {
        display: none;
    }

    .ttw-row.rec .ttw-ok,
    .ttw-row.rec .ttw-cancel {
        display: inline-block;
    }

    /* center the waves pill on the row and leave room for the right button cluster */
    .ttw-waves {
        position: absolute;
        left: 14px;
        right: 220px; /* room for mic + OK + Ä°ptal */
        top: 50%;
        height: 40px;
        transform: translateY(-50%);
        display: none;
        align-items: flex-end;
        gap: 6px;
        padding: 6px 10px;
        border-radius: 999px;
        background: rgba(16, 163, 127, .08);
        box-shadow: inset 0 0 0 1px rgba(16, 163, 127, .12), 0 4px 12px rgba(16, 163, 127, .06);
        pointer-events: none;
        opacity: 0;
        transition: opacity .18s ease, transform .18s ease;
    }

    .ttw-waves.on {
        display: flex;
        opacity: 1;
    }

    .ttw-waves::before {
        content: 'Dinliyorum...';
        font-size: 14px;
        color: #19a974;
        margin-right: 8px;
        align-self: center;
    }

    /* each bar */
    .ttw-waves .bar {
        flex: 1 1 4px;
        max-width: 4px;
        height: 40%;
        border-radius: 2px;
        transform-origin: bottom center;
        background: linear-gradient(to top, rgba(16, 163, 127, .95), rgba(16, 163, 127, .45));
        box-shadow: 0 1px 2px rgba(0, 0, 0, .06);
    }


    /* small mobile tweak so the pill doesnâ€™t collide with the edge */
    @media (max-width: 768px) {
        .ttw-waves {
            left: 12px;
            right: 140px;
            bottom: 10px;
        }
    }

    /* ============ GALLERY ============ */
    .ttw-b.has-gallery {
        max-width: 100%;
    }

    .ttw-gallery {
        display: grid;
        grid-template-columns:repeat(2, minmax(0, 1fr));
        gap: 10px;
    }

    @media (min-width: 480px) {
        .ttw-gallery {
            grid-template-columns:repeat(3, 1fr);
        }
    }

    @media (min-width: 768px) {
        .ttw-gallery {
            grid-template-columns:repeat(4, 1fr);
        }
    }

    .ttw-gallery .tile {
        display: flex;
        flex-direction: column;
        border-radius: 10px;
        overflow: hidden;
        background: #fff;
        transition: box-shadow .15s;
        border: 1px solid #efeff1;
    }

    .ttw-gallery .tile:hover {
        box-shadow: 0 4px 12px rgba(0, 0, 0, .12);
    }

    .ttw-gallery .img-wrap {
        width: 100%;
        height: 100px;
        overflow: hidden;
    }

    .ttw-gallery img {
        width: 100%;
        height: 100%;
        object-fit: cover;
        display: block;
        transition: transform .18s ease;
    }

    .ttw-gallery .tile:hover .img-wrap img {
        transform: scale(1.035);
    }

    /* caption clamp (2 lines) */
    .ttw-gallery .cap {
        --cap-lh: 1.3;
        padding: 8px 10px;
        font-size: 12px;
        line-height: var(--cap-lh);
        color: #111;
        display: -webkit-box;
        -webkit-box-orient: vertical;
        -webkit-line-clamp: 2;
        overflow: hidden;
        text-overflow: ellipsis;
        min-height: calc(2 * var(--cap-lh) * 1em);
        white-space: normal !important;
        overflow-wrap: anywhere;
        word-break: normal;
        hyphens: auto;
    }

    @supports not (-webkit-line-clamp:2) {
        .ttw-gallery .cap {
            display: block;
            max-height: calc(2 * var(--cap-lh) * 1em);
            overflow: hidden;
        }
    }

    /* ============ MODAL CHROME ============ */
    body.tw-modal-open {
        overflow: hidden;
    }

    .tw-overlay {
        position: fixed;
        inset: 0;
        background: rgba(15, 16, 30, .45);
        backdrop-filter: blur(2px);
        z-index: 10000;
        opacity: 0;
        transition: opacity .38s ease;
    }

    .tw-overlay.open {
        opacity: 1;
    }

    .tw-panel {
        position: fixed;
        z-index: 10001;
        background: #fff;
        border-radius: 16px;
        box-shadow: 0 16px 48px rgba(0, 0, 0, .24);
        display: flex;
        flex-direction: column;
        overflow: hidden;
        left: calc(50% - 380px);
        top: 10vh;
        width: 760px;
        height: 78vh;
        transform-origin: top left;
        transition: transform .38s cubic-bezier(.2, .7, .2, 1), opacity .38s ease;
        will-change: transform, opacity;
        opacity: 0;
    }

    .tw-head {
        position: sticky;
        top: 0;
        z-index: 2;
        padding: 12px 56px 12px 16px;
        padding-right: 72px;
        font-weight: 600;
        background: #fff;
        color: #0c0c0d;
        border-bottom: 1px solid #e5e7eb;
    }

    .tw-close {
        position: absolute;
        top: 8px;
        right: 8px;
        width: 40px;
        height: 40px;
        border-radius: 999px;
        border: 0;
        background: rgba(0, 0, 0, .45);
        color: #fff;
        cursor: pointer;
        font-size: 22px;
        display: grid;
        place-items: center;
        z-index: 9;
    }

    /* TTS toggle button */
    .tw-tts {
        position: absolute;
        top: 8px;
        right: 52px;
        z-index: 9;
        width: 40px;
        height: 40px;
        border-radius: 999px;
        border: 0;
        cursor: pointer;
        background: rgba(0, 0, 0, .12);
        color: #111;
        font-size: 16px;
    }

    .tw-tts.on {
        background: #10a37f;
        color: #fff;
    }

    .tw-tts.speaking::after {
        content: '';
        position: absolute;
        inset: 6px;
        border-radius: 50%;
        border: 2px solid currentColor;
        animation: ttw-tts-wave 1s infinite ease-in-out;
    }

    @keyframes ttw-tts-wave {
        0% {
            transform: scale(1);
            opacity: 1
        }
        100% {
            transform: scale(1.6);
            opacity: 0
        }
    }

    .tw-body {
        flex: 1;
        overflow: auto;
        padding: 10px;
        background: #fff;
        display: flex;
        flex-direction: column;
    }

    .tw-body .ttw-chatbot {
        gap: 10px;
        display: flex;
        flex-direction: column;
        flex: 1;
        min-height: 0;
    }

    .tw-body .ttw-log {
        height: auto;
        flex: 1;
        min-height: 0;
    }

    /* typing indicator */
    .ttw-b.ttw-typing {
        margin-right: auto;
        color: #3b4a6b;
        background: #eef3ff;
    }

    .ttw-typing .dots {
        display: inline-flex;
        gap: 4px;
        vertical-align: middle;
    }

    .ttw-typing .dot {
        width: 6px;
        height: 6px;
        border-radius: 50%;
        background: #3b4a6b;
        opacity: .32;
        animation: ttw-bounce 1s infinite ease-in-out;
    }

    .ttw-typing .dot:nth-child(2) {
        animation-delay: .15s;
    }

    .ttw-typing .dot:nth-child(3) {
        animation-delay: .3s;
    }

    @keyframes ttw-bounce {
        0%, 80%, 100% {
            transform: translateY(0);
            opacity: .32
        }
        40% {
            transform: translateY(-4px);
            opacity: .95
        }
    }

    /* hide mini launcher while modal open */
    body.tw-modal-open #miniChatCard {
        opacity: 0;
        pointer-events: none;
        transition: opacity .3s ease;
    }

    /* ============ MOBILE TWEAKS ============ */
    @media (max-width: 768px) {
        .tw-panel {
            left: 0;
            top: 0;
            width: 100vw;
            height: 100dvh;
            border-radius: 0;
            box-shadow: none;
        }

        .tw-body {
            padding: 10px env(safe-area-inset-right) calc(10px + env(safe-area-inset-bottom)) env(safe-area-inset-left);
        }

        .tw-head {
            padding-left: 16px;
            padding-right: 72px;
        }

        .tw-close {
            top: 6px;
            right: 6px;
            background: rgba(0, 0, 0, .3);
        }

        .ttw-row {
            padding: 0 12px;
            margin-bottom: 40px;
        }

        .tw-body {
            padding-bottom: 64px;
        }

        .tw-tts {
            top: 6px;
            right: 52px;
            background: rgba(0, 0, 0, .2);
            color: #fff;
        }
    }

    /* optional disclaimer (mobile) */
    .ttw-disclaimer {
        display: none;
    }

    @media (max-width: 768px) {
        .ttw-disclaimer {
            display: block;
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            z-index: 9999;
            padding: 8px;
            background: #f1f3f5;
            color: #444;
            font-size: 12px;
            text-align: center;
        }
    }
</style>


<script>
    (() => {
        /* ---------------- Debug (F9) ---------------- */
        const DBG = {box: null, body: null, lines: []};
        const dlog = (...a) => {
            try {
                if (!DBG.box) {
                    const el = document.createElement("div");
                    el.className = "ttw-debug";
                    el.innerHTML = '<div class="hd">TTW Debug (F9)</div><div class="bd"></div>';
                    document.body.appendChild(el);
                    DBG.box = el;
                    DBG.body = el.querySelector(".bd");
                    window.addEventListener("keydown", (e) => {
                        if (e.key === "F9") DBG.box.classList.toggle("open");
                    });
                }
                const line = `[${new Date().toLocaleTimeString()}] ` + a.map(x => {
                    try {
                        return typeof x === "string" ? x : JSON.stringify(x);
                    } catch {
                        return String(x);
                    }
                }).join(" ");
                DBG.lines.push(line);
                if (DBG.lines.length > 400) DBG.lines.shift();
                DBG.body.textContent = DBG.lines.join("\n");
                DBG.body.scrollTop = DBG.body.scrollHeight;
                console.log("[TTW]", ...a);
            } catch {
            }
        };

        const getSid = () => {
            try {
                let sid = localStorage.getItem("ttw_sid");
                if (!sid) {
                    sid = crypto?.randomUUID?.() || Math.random().toString(36).slice(2);
                    localStorage.setItem("ttw_sid", sid);
                }
                return sid;
            } catch {
                return Math.random().toString(36).slice(2);
            }
        };

        const normalizeMd = s => (s || "").replace(/\r\n/g, "\n").replace(/\r/g, "\n").replace(/\\n/g, "\n");

        /* ---------- bubbles ---------- */
        function addBubble(chatEl, text, who) {
            if (!chatEl) return;
            const w = document.createElement("div");
            w.className = "ttw-b " + (who === "user" ? "u" : "a");
            w.innerHTML = marked.parse(normalizeMd(text || ""));
            const ts = document.createElement("div");
            ts.className = "ttw-ts";
            ts.textContent = new Date().toLocaleTimeString();
            w.appendChild(ts);
            chatEl.appendChild(w);
            chatEl.scrollTop = chatEl.scrollHeight;
        }

        /* typing indicator bubble */
        function showTyping(chatEl) {
            const b = document.createElement("div");
            b.className = "ttw-b a ttw-typing";
            b.innerHTML = '<span class="dots"><span class="dot"></span><span class="dot"></span><span class="dot"></span></span>';
            chatEl.appendChild(b);
            chatEl.scrollTop = chatEl.scrollHeight;
            return () => {
                try {
                    b.remove();
                } catch {
                }
            };
        }

        /* split reply into steps (paragraphs) */
        function splitSteps(text) {
            const raw = text || "";
            const norm = normalizeMd(raw).replace(/\n{3,}/g, "\n\n").trim();
            if (!norm) return [];
            const blocks = norm.split(/\n\s*\n/);
            dlog("MD â–¶ BLOCKS", blocks.map(b => (b.slice(0, 80) + "â€¦").replace(/\n/g, "âŽ")));
            return blocks.slice(0, 12);
        }

        /* url resolver */
        function resolveUrl(u) {
            if (!u) return null;
            if (/^https?:\/\//i.test(u)) return u;
            if (u.startsWith("//")) return location.protocol + u;
            if (u.startsWith("/")) return location.origin + u;
            return location.origin + "/" + u.replace(/^\.?\//, "");
        }

        /* ===== HARD CLAMP (gallery captions) ===== */
        function hardClampCaptions(scope) {
            const doClamp = () => {
                const caps = (scope || document).querySelectorAll(".ttw-gallery .cap");
                caps.forEach((el) => {
                    const cs = getComputedStyle(el);
                    let lh = parseFloat(cs.lineHeight);
                    if (!isFinite(lh)) {
                        const fs = parseFloat(cs.fontSize) || 12;
                        lh = fs * 1.3;
                    }
                    const maxH = Math.round(lh * 2);
                    if (el.scrollHeight > maxH + 1) {
                        const full = (el.getAttribute("data-full") || el.textContent || "").trim().replace(/\s+/g, " ");
                        let lo = 0, hi = full.length, best = "";
                        while (lo <= hi) {
                            const mid = (lo + hi) >> 1;
                            el.textContent = full.slice(0, mid).trim() + "â€¦";
                            if (el.scrollHeight <= maxH + 1) {
                                best = el.textContent;
                                lo = mid + 1;
                            } else hi = mid - 1;
                        }
                        el.textContent = best || full.slice(0, 2) + "â€¦";
                        if (!el.title) el.title = full;
                    }
                });
            };
            requestAnimationFrame(() => requestAnimationFrame(doClamp));
        }

        /* ---- gallery ---- */
        function addImageGallery(chatEl, items) {
            if (!chatEl || !items?.length) return;
            const wrap = document.createElement("div");
            wrap.className = "ttw-b a has-gallery";
            const grid = document.createElement("div");
            grid.className = "ttw-gallery";

            items.slice(0, 12).forEach((it) => {
                const obj = typeof it === "string" ? {image: it, adres: it} : it || {};
                const imgSrc = resolveUrl(obj.image || obj.adres);
                const href = resolveUrl(obj.adres || obj.image);
                if (!imgSrc) return;
                const tile = document.createElement("a");
                tile.className = "tile";
                tile.href = href || imgSrc;
                tile.target = "_blank";
                tile.rel = "noopener noreferrer";
                const imgWrap = document.createElement("div");
                imgWrap.className = "img-wrap";
                const img = document.createElement("img");
                img.src = imgSrc;
                img.alt = obj.title || "gÃ¶rsel";
                img.loading = "lazy";
                imgWrap.appendChild(img);
                tile.appendChild(imgWrap);

                const cap = document.createElement("div");
                cap.className = "cap";
                const title = (obj.title || "").trim();
                cap.textContent = title;
                cap.title = title;
                cap.setAttribute("data-full", title);
                tile.appendChild(cap);

                grid.appendChild(tile);
            });

            wrap.appendChild(grid);
            const ts = document.createElement("div");
            ts.className = "ttw-ts";
            ts.textContent = new Date().toLocaleTimeString();
            wrap.appendChild(ts);
            chatEl.appendChild(wrap);
            chatEl.scrollTop = chatEl.scrollHeight;

            hardClampCaptions(wrap);
        }

        /* endpoint resolution */
        function resolveEndpoint(root, opts) {
            const scheme = location.protocol === "https:" ? "wss" : "ws";
            if (opts?.endpoint) return opts.endpoint;
            if (root?.dataset.endpoint) return root.dataset.endpoint;
            if (window.TTW_WS) return window.TTW_WS;
            if (location.port === "9000") return `${scheme}://${location.hostname}:8000/ws`;
            return `${scheme}://${location.host}/ws`;
        }

        const pageRect = (el) => {
            const r = el.getBoundingClientRect();
            return {left: r.left + scrollX, top: r.top + scrollY, width: r.width, height: r.height};
        };

        /* ---------------- Modal with grow-from-origin ---------------- */
        function openModal(opts) {
            const overlay = document.createElement("div");
            overlay.className = "tw-overlay";
            const panel = document.createElement("div");
            panel.className = "tw-panel";
            panel.innerHTML = `
      <div class="tw-head">
        Olivia Â· CanlÄ± Sohbet
        <button class="tw-tts" type="button" title="Sesi aÃ§/kapat" aria-pressed="false">ðŸ”ˆ</button>
        <button class="tw-close" type="button">Ã—</button>
      </div>
      <div class="tw-body">
        <div class="ttw-chatbot" data-ttw-chatbot data-autoinit="1">
          <header class="ttw-h"><h2>AI Chatbot</h2><div class="s">Size yardÄ±mcÄ± olmak iÃ§in buradayÄ±m</div></header>
          <div class="ttw-log" role="log" aria-live="polite"></div>
          <form class="ttw-row" autocomplete="off">
            <input class="ttw-inp" type="text" placeholder="MesajÄ±nÄ±zÄ± yazÄ±n..." aria-label="MesajÄ±nÄ±zÄ± yazÄ±n">
            <div class="ttw-waves" aria-hidden="true">
            </div>
            <button class="ttw-mic" type="button" id="ttwMic" aria-pressed="false" title="Sesle yaz"></button>
            <button class="ttw-btn ttw-send" type="button" id="ttwSend">GÃ¶nder</button>
            <button class="ttw-btn ttw-ok" type="button" id="ttwOk" style="display:none;background:#19a974;color:#fff">OK</button>
            <button class="ttw-btn ttw-cancel" type="button" id="ttwCancel" style="display:none;background:#fff;box-shadow:0 0 0 1px rgba(0,0,0,.12) inset">Ä°ptal</button>
          </form>
          <div class="ttw-disclaimer">Olivia, TalktoWeb Teknoloji DepartmanÄ± tarafÄ±ndan geliÅŸtirilen bir yapay zeka robotudur</div>
        </div>
      </div>`;
            document.body.append(overlay, panel);
            document.body.classList.add("tw-modal-open");

            // round mic icon
            const micBtn = panel.querySelector("#ttwMic");
            if (micBtn) {
                micBtn.innerHTML = `
        <svg width="18" height="18" viewBox="0 0 24 24" aria-hidden="true">
                        <path d="M12 14a3 3 0 0 0 3-3V6a3 3 0 0 0-6 0v5a3 3 0 0 0 3 3zm5-3a5 5 0 0 1-10 0H5a7 7 0 0 0 14 0h-2zM11 19h2v3h-2v-3z"/>
                    </svg>`;
            }

            const originEl = typeof opts?.animateFrom === "string" ? document.querySelector(opts.animateFrom) : (opts?.animateFrom || null);
            const doGrow = originEl && originEl.getBoundingClientRect().width > 0 && originEl.getBoundingClientRect().height > 0;

            function setFromOrigin() {
                const t = panel.getBoundingClientRect(), p = pageRect(panel), o = pageRect(originEl);
                const sx = Math.max(0.01, o.width / t.width), sy = Math.max(0.01, o.height / t.height);
                const dx = (o.left - p.left), dy = (o.top - p.top);
                panel.style.transformOrigin = "top left";
                panel.style.transform = `translate(${dx}px,${dy}px) scale(${sx},${sy})`;
                panel.style.opacity = "0.001";
            }

            requestAnimationFrame(() => {
                if (doGrow) setFromOrigin();
                requestAnimationFrame(() => {
                    overlay.classList.add("open");
                    panel.style.transform = "none";
                    panel.style.opacity = "1";
                });
            });

            const controller = mount(panel.querySelector("[data-ttw-chatbot]"), opts || {});

            function close() {
                if (doGrow) {
                    setFromOrigin();
                    overlay.classList.remove("open");
                    const done = () => {
                        panel.removeEventListener("transitionend", done);
                        cleanup();
                    };
                    panel.addEventListener("transitionend", done);
                } else cleanup();
            }

            function cleanup() {
                try {
                    controller?.destroy?.();
                } catch {
                }
                try {
                    overlay.remove();
                } catch {
                }
                try {
                    panel.remove();
                } catch {
                }
                document.body.classList.remove("tw-modal-open");
            }

            panel.querySelector(".tw-close").onclick = (e) => {
                e.preventDefault();
                close();
            };
            overlay.onclick = (e) => {
                if (e.target === overlay) close();
            };
        }

        /* ---------------- Core mount ---------------- */
        function mount(root, opts) {
            const row = root.querySelector(".ttw-row");

            if (!root) return {
                destroy() {
                }
            };

            // --- DOM refs ---
            const chat = root.querySelector(".ttw-log");
            const input = root.querySelector(".ttw-inp");
            const sendB = root.querySelector(".ttw-send");
            const form = root.querySelector("form");
            const mic = root.querySelector("#ttwMic");
            const waves = root.querySelector(".ttw-waves");
            const okB = root.querySelector("#ttwOk");
            const cancelB = root.querySelector("#ttwCancel");

            // --- Voice state ---
            const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
            let rec = null, listening = false, starting = false;
            let finalBuf = "", interimBuf = "";
            let srKeepAlive = false;
            let mediaStream = null; // for analyser waves

            // --- WebAudio waves ---
            // --- WebAudio waves ---
            let audioCtx = null, analyser = null, rafId = 0, agc = 0.15;

            function buildWavesUI() {
                if (!waves) return;
                waves.innerHTML = '';
                const lbl = document.createElement('span');
                lbl.className = 'lbl';
                lbl.textContent = 'Dinliyorumâ€¦';
                const meter = document.createElement('span');
                meter.className = 'meter';
                for (let i = 0; i < 16; i++) {
                    const b = document.createElement('span');
                    b.className = 'bar';
                    meter.appendChild(b);
                }
                waves.append(lbl, meter);
                return Array.from(meter.children);
            }

            function startWaves(stream) {
                if (!waves) return;
                try {
                    // make sure we have bars
                    let bars = Array.from(waves.querySelectorAll('.bar'));
                    if (bars.length === 0) {
                        const targetBars = 28;                // nice density
                        const frag = document.createDocumentFragment();
                        for (let i = 0; i < targetBars; i++) {
                            const b = document.createElement('span');
                            b.className = 'bar';
                            frag.appendChild(b);
                        }
                        waves.appendChild(frag);
                        bars = Array.from(waves.querySelectorAll('.bar'));
                    }

                    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    const src = audioCtx.createMediaStreamSource(stream);

                    analyser = audioCtx.createAnalyser();
                    analyser.fftSize = 1024;
                    analyser.smoothingTimeConstant = 0.75;

                    const freq = new Uint8Array(analyser.frequencyBinCount);
                    const step = Math.floor(freq.length / bars.length);
                    const gain = 1.8;                        // responsiveness boost

                    const draw = () => {
                        analyser.getByteFrequencyData(freq);
                        for (let i = 0; i < bars.length; i++) {
                            let sum = 0;
                            for (let j = i * step; j < (i + 1) * step; j++) sum += freq[j];
                            const v = (sum / step) / 255;            // 0..1
                            const s = Math.max(0.12, Math.min(1.25, v * gain));
                            bars[i].style.transform = `scaleY(${s})`;
                        }
                        rafId = requestAnimationFrame(draw);
                    };

                    waves.classList.add('on');
                    src.connect(analyser);
                    draw();
                } catch (e) {
                    console.warn('waves init failed', e);
                }
            }

            function stopWaves() {
                try {
                    cancelAnimationFrame(rafId);
                } catch {
                }
                rafId = 0;
                waves?.classList.remove('on');
                // leave DOM â€” it will rebuild next time
            }

            // Input UI toggle (donâ€™t disable input)
            function toggleRecordUI(on) {
                const oldph = input.getAttribute('data-oldph') || input.placeholder || '';
                if (!input.getAttribute('data-oldph')) input.setAttribute('data-oldph', oldph);

                root.querySelector('.ttw-row')?.classList.toggle('rec', !!on);
                mic?.classList.toggle('rec', !!on);
                waves?.classList.toggle('on', !!on);

                if (sendB) sendB.style.display = on ? 'none' : 'inline-block';
                if (okB) okB.style.display = on ? 'inline-block' : 'none';
                if (cancelB) cancelB.style.display = on ? 'inline-block' : 'none';

                if (on) {
                    input.classList.add('is-voice');
                    input.placeholder = 'Dinliyorumâ€¦';
                    input.setAttribute('aria-label', 'Dinliyorumâ€¦');
                } else {
                    input.classList.remove('is-voice');
                    input.placeholder = input.getAttribute('data-oldph') || 'MesajÄ±nÄ±zÄ± yazÄ±n...';
                    input.setAttribute('aria-label', 'MesajÄ±nÄ±zÄ± yazÄ±n');
                }
            }

            function srSupported() {
                return !!SR;
            }

            function srStop() {
                srKeepAlive = false;
                try {
                    rec && rec.stop();
                } catch {
                }
                listening = false;
                toggleRecordUI(false);
                stopWaves();
                try {
                    mediaStream?.getTracks()?.forEach(t => t.stop());
                } catch {
                }
                mediaStream = null;
            }

            async function srStart() {
                if (starting || listening) return;
                if (!srSupported()) {
                    console.warn("SpeechRecognition not supported");
                    mic && (mic.disabled = true);
                    return;
                }
                starting = true;
                srKeepAlive = true;
                toggleRecordUI(true);

                // ensure mic stream for waves + permission prompt
                try {
                    mediaStream = mediaStream || await navigator.mediaDevices.getUserMedia({audio: true});
                    startWaves(mediaStream);
                } catch (err) {
                    console.warn('Mic permission error', err);
                }

                rec = new SR();
                rec.lang = 'tr-TR';
                rec.interimResults = true;
                rec.continuous = true;

                rec.onstart = () => {
                    starting = false;
                    listening = true;
                };

                rec.onresult = (e) => {
                    interimBuf = '';
                    for (let i = e.resultIndex; i < e.results.length; i++) {
                        const chunk = e.results[i][0].transcript;
                        if (e.results[i].isFinal) finalBuf += chunk + ' ';
                        else interimBuf += chunk;
                    }
                    // live preview while speaking
                    input.value = (finalBuf + ' ' + interimBuf).replace(/\s+/g, ' ').trim();
                };

                rec.onerror = () => { /* keep UI; we'll restart in onend */
                };

                rec.onend = () => {
                    if (srKeepAlive) {
                        try {
                            rec.start();
                        } catch {
                            setTimeout(() => {
                                try {
                                    rec.start();
                                } catch {
                                }
                            }, 200);
                        }
                    }
                };

                try {
                    rec.start();
                } catch (err) {
                    starting = false;
                    console.warn('SR start fail', err);
                }
            }

            mic?.addEventListener('click', () => {
                (!listening && !starting) ? srStart() : srStop();
            });
            cancelB?.addEventListener('click', () => {
                srStop();
                input.value = (input.value || '').trim();
                input.focus();
            });
            okB?.addEventListener('click', () => {
                srStop();
                input.focus();
            });
            input?.addEventListener('keydown', () => {
                if (listening) srStop();
            });

            // ---------- TTS ----------
            const panelEl = root.closest(".tw-panel");
            const ttsBtn = panelEl?.querySelector(".tw-tts");
            const tts = {
                enabled: false,
                voice: null,
                rate: 1.0,
                pitch: 1.1,
                volume: 1.0,
                chosenName: localStorage.getItem('ttw_tts_voice') || null,
                audio: null,
                lastUrl: null
            };

            function ttsSupported() {
                return 'speechSynthesis' in window && 'SpeechSynthesisUtterance' in window;
            }

            function listVoicesSafe() {
                try {
                    return speechSynthesis.getVoices() || [];
                } catch {
                    return [];
                }
            }

            function rankVoice(v) {
                let s = 0;
                const n = (v.name || '').toLowerCase(), l = (v.lang || '').toLowerCase();
                if (l.startsWith('tr')) s += 5;
                if (l.includes('tr-tr')) s += 2;
                if (/seda|filiz|yelda|female|kadin/.test(n)) s += 6;
                if (/google|microsoft|online|natural/.test(n)) s += 2;
                if (!l.startsWith('tr') && /samantha|serena|victoria|aria|jenny|zira|emma|amy|joanna/.test(n)) s += 1;
                return s;
            }

            function pickVoice(preferred) {
                const vs = listVoicesSafe();
                if (!vs.length) return null;
                if (preferred) {
                    const f = vs.find(v => v.name === preferred);
                    if (f) return f;
                }
                const ranked = [...vs].sort((a, b) => rankVoice(b) - rankVoice(a));
                return ranked.find(v => (v.lang || '').toLowerCase().startsWith('tr')) || ranked[0] || null;
            }

            function initVoicesOnce() {
                if (!ttsSupported()) return;
                tts.voice = pickVoice(tts.chosenName);
                try {
                    speechSynthesis.onvoiceschanged = () => {
                        const prev = tts.voice && tts.voice.name;
                        tts.voice = pickVoice(tts.chosenName || prev);
                        updateTtsBtn();
                    };
                } catch {
                }
            }

            function cleanForTTS(s) {
                return (s || "").replace(/!\[[^\]]*\]\([^)]+\)/g, '$1').replace(/\[([^\]]+)\]\([^)]+\)/g, '$1').replace(/https?:\/\/\S+|www\.\S+|\S+@\S+/g, ' ').replace(/\bM\.?S\.?\b/gi, ' ').replace(/(>=|<=|=>|->|<-|==|!=|â‰ˆ|Â±|â†”|â‡’|â‡”|â†’|â†|â‰¥|â‰¤)/g, ' ').replace(/[=+\-/*<>|\\^~`_%$â‚¬Â£Â¥Â©Â®â„¢Â°\[\]{}()@#:;]/g, ' ').replace(/[`*_#>{}<~^]+/g, ' ').replace(/[!?]{2,}/g, '!').replace(/\.{3,}/g, '.').replace(/\s+/g, ' ').trim();
            }

            function ttsStop() {
                try {
                    speechSynthesis.cancel?.()
                } catch {
                }
                ;
                try {
                    if (tts.audio) {
                        tts.audio.pause();
                        tts.audio.src = '';
                        tts.audio = null;
                    }
                    if (tts.lastUrl) {
                        URL.revokeObjectURL(tts.lastUrl);
                        tts.lastUrl = null;
                    }
                } catch {
                }
            }

            function updateTtsBtn() {
                if (!ttsBtn) return;
                ttsBtn.classList.toggle('on', tts.enabled);
                ttsBtn.setAttribute('aria-pressed', String(tts.enabled));
                ttsBtn.textContent = tts.enabled ? 'ðŸ”Š' : 'ðŸ”ˆ';
                if (tts.voice) ttsBtn.title = `Sesi ${tts.enabled ? 'kapat' : 'aÃ§'} Â· ${tts.voice.name}`;
            }

            ttsBtn?.addEventListener('click', (ev) => {
                if (ev.altKey) return;
                tts.enabled = !tts.enabled;
                if (tts.enabled && ttsSupported()) initVoicesOnce();
                if (!tts.enabled) ttsStop();
                updateTtsBtn();
            });
            ttsBtn?.addEventListener('click', (ev) => {
                if (!ev.altKey) return;
                ev.preventDefault();
                if (!ttsSupported()) return;
                const vs = listVoicesSafe();
                if (!vs.length) return;
                const pool = vs.filter(v => (v.lang || '').toLowerCase().startsWith('tr'));
                const list = pool.length ? pool : vs;
                if (!tts.voice) tts.voice = pickVoice(tts.chosenName);
                const idx = Math.max(0, list.findIndex(v => tts.voice && v.name === tts.voice.name));
                const next = list[(idx + 1) % list.length];
                if (next) {
                    tts.voice = next;
                    tts.chosenName = next.name;
                    localStorage.setItem('ttw_tts_voice', next.name);
                    updateTtsBtn();
                }
            });
            updateTtsBtn();
            if (ttsSupported()) initVoicesOnce();

            // base + endpoints
            const base = resolveEndpoint(root, opts);
            const httpBase = base.replace(/^wss:/, "https:").replace(/^ws:/, "http:").replace(/\/ws.*/, "");
            const ttsEndpoint = httpBase + "/tts";

            // prepare TTS and get duration for sync
            async function speakAndGetDuration(text) {
                if (!tts.enabled) return {
                    play: async () => {
                    }, durationMs: 0
                };
                const clean = cleanForTTS(text || "");
                if (!clean) return {
                    play: async () => {
                    }, durationMs: 0
                };
                const res = await fetch(ttsEndpoint, {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({text: clean, provider: 'polly', voice: 'Burcu'})
                });
                if (!res.ok) return {
                    play: async () => {
                    }, durationMs: 0
                };
                const blob = await res.blob();
                const url = URL.createObjectURL(blob);

                // probe duration
                const probe = new Audio();
                const durationMs = await new Promise(r => {
                    probe.preload = 'metadata';
                    probe.src = url;
                    probe.onloadedmetadata = () => r(Math.max(0, (probe.duration || 0) * 1000));
                    probe.onerror = () => r(0);
                });

                const play = () => new Promise(resolve => {
                    try {
                        if (tts.audio) tts.audio.pause();
                    } catch {
                    }
                    tts.audio = new Audio(url);
                    tts.lastUrl = url;
                    tts.audio.onended = () => {
                        try {
                            URL.revokeObjectURL(url);
                        } catch {
                        }
                        if (tts.lastUrl === url) tts.lastUrl = null;
                        resolve();
                    };
                    tts.audio.play().catch(() => resolve());
                });

                return {play, durationMs: durationMs || Math.max(1200, clean.length * 55)};
            }

            // typewriter that accepts msPerChar
            function typeWriter(el, text, msPerChar = 16) {
                return new Promise(res => {
                    const full = normalizeMd(text || "");
                    let i = 0, len = full.length;
                    const id = setInterval(() => {
                        i++;
                        el.innerHTML = marked.parse(full.slice(0, i));
                        if (i >= len) {
                            clearInterval(id);
                            res();
                        }
                    }, msPerChar);
                });
            }

            // assistant render with sync
            const renderAssistantReply = async (chatEl, fullText) => {
                const steps = splitSteps(fullText).slice(0, 8);
                for (const step of steps) {
                    const remove = showTyping(chatEl);
                    const w = document.createElement('div');
                    w.className = 'ttw-b a';
                    chatEl.appendChild(w);
                    chatEl.scrollTop = chatEl.scrollHeight;
                    remove();

                    let msPerChar = 16;
                    let playAudio = async () => {
                    };
                    try {
                        const {play, durationMs} = await speakAndGetDuration(step);
                        playAudio = play;
                        if (durationMs && step.length) {
                            msPerChar = Math.ceil(durationMs / step.length);
                            msPerChar = Math.min(Math.max(msPerChar, 8), 64);
                        }
                    } catch {
                    }

                    await Promise.all([typeWriter(w, step, msPerChar), playAudio()]);

                    const ts = document.createElement('div');
                    ts.className = 'ttw-ts';
                    ts.textContent = new Date().toLocaleTimeString();
                    w.appendChild(ts);
                }
            };

            // ---------- WS ----------
            const url = base + (base.includes('?') ? '&' : '?') + 'client_id=' + encodeURIComponent(getSid());
            let ws = null, open = false, q = [];
            let typingHintRemove = null;

            function connect() {
                try {
                    dlog('WS connecting â†’', url);
                    ws = new WebSocket(url);
                    ws.addEventListener('open', () => {
                        open = true;
                        dlog('WS open');
                        while (q.length) {
                            try {
                                ws.send(q.shift());
                            } catch {
                                break;
                            }
                        }
                    });
                    ws.addEventListener('message', onMsg);
                    ws.addEventListener('error', e => dlog('WS error', e));
                    ws.addEventListener('close', () => {
                        open = false;
                        dlog('WS close â€” retry in 1.2s');
                        setTimeout(connect, 1200);
                    });
                } catch (err) {
                    dlog('WS ctor error', err);
                    setTimeout(connect, 900);
                }
            }

            function sendRaw(s) {
                if (!s) return;
                if (ws && open && ws.readyState === 1) {
                    try {
                        ws.send(s);
                        dlog('WS â†’', s);
                    } catch (e) {
                        dlog('WS send err', e);
                    }
                } else {
                    q.push(s);
                    dlog('WS queued', s);
                }
            }

            function send() {
                const txt = (input?.value || "").trim();
                if (!txt) return;
                addBubble(chat, txt, "user");
                typingHintRemove?.();
                typingHintRemove = showTyping(chat);
                sendRaw(txt);
                if (input) input.value = "";
            }

            async function onMsg(ev) {
                dlog('WS â†', ev.data);
                try {
                    typingHintRemove?.();
                    typingHintRemove = null;
                } catch {
                }
                try {
                    const data = JSON.parse(ev.data);
                    if (data.reply) await renderAssistantReply(chat, data.reply);

                    let urls = data.urls;
                    if (typeof urls === "string") {
                        try {
                            urls = JSON.parse(urls);
                        } catch {
                        }
                    }
                    if (!Array.isArray(urls) && typeof data.reply === "string") {
                        const m = data.reply.match(/"urls"\s*:\s*(\[[\s\S]*?\])/);
                        if (m) {
                            try {
                                urls = JSON.parse(m[1]);
                            } catch {
                            }
                        }
                    }
                    if (Array.isArray(urls) && urls.length) {
                        addImageGallery(chat, urls.map(u => {
                            if (typeof u === 'string') return u;
                            const o = u || {};
                            return {
                                adres: o.adres || o.url || o.href || o.image || '',
                                image: o.image || o.src || o.adres || '',
                                title: o.title || o.name || o.caption || o.text || ''
                            };
                        }));
                    }
                } catch {
                    await renderAssistantReply(chat, ev.data);
                }
            }

            form?.addEventListener('submit', e => {
                e.preventDefault();
                e.stopPropagation();
            });
            sendB?.addEventListener('click', e => {
                e.preventDefault();
                e.stopPropagation();
                send();
            });
            input?.addEventListener('keydown', e => {
                if (e.key === 'Enter' && !e.shiftKey) {
                    e.preventDefault();
                    send();
                }
            });

            // stop voice when modal closes
            const mo = new MutationObserver(() => {
                if (!document.body.classList.contains('tw-modal-open')) srStop();
            });
            mo.observe(document.body, {attributes: true, attributeFilter: ['class']});

            connect();
            const first = (opts.initialText || '').trim();
            if (first) {
                addBubble(chat, first, 'user');
                typingHintRemove?.();
                typingHintRemove = showTyping(chat);
                sendRaw(first);
            }

            return {
                destroy() {
                    try {
                        srStop()
                    } catch {
                    }
                    try {
                        mo.disconnect()
                    } catch {
                    }
                    try {
                        ttsStop()
                    } catch {
                    }
                    try {
                        ws?.close()
                    } catch {
                    }
                }
            };
        }

        // expose
        window.TTWChatbot = {openModal, mount};

        // auto-init
        document.addEventListener('DOMContentLoaded', () => {
            document.querySelectorAll('[data-ttw-chatbot][data-autoinit]').forEach(root => mount(root, {}));
        });
        window.addEventListener('error', e => dlog('window error', e.message || e));
        window.addEventListener('unhandledrejection', e => dlog('promise rejection', e.reason || e));
    })();
</script>
